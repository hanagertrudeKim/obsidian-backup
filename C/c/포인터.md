## 포인터


### 포인터의 정의 
- 메모리의 주소를 갖고있는 변수
- 포인터를 이용하면 변수를 간접적으로 참조할 수 있다.
- 주소 연산자: & 
- 간접 참조 연산자 : * 
	- ` *p `  -> p가 가르키는 위치에 있는 데이터를 가져오라는 의미

### 포인터의 선언
```c
int * p  // 정수를 가리키는 포인터p

char * pc;  //문자를 가리키는 포인터 pc
float * pf;  //실수를 가리키는 포인터 pf
double * pd;  //실수를 가리키는 포인터 pd

int *p1 *p2 *p3 //여러개의 포인터 선언
```

- 포인터에 존재하는 데이터 유형 
	- 포인터가 가르키는 데이터에 따라 주소값이 달라진다. 
	- ex ) `char`  형은 1 byte -> 주소값이 1 unit으로  움직임
	  `int` 형은 4 byte -> 주소값이 4 unit으로  움직임


***왜 포인터에 다양한 타입이 존재하는가 ? 
--> 포인터가 가르치는 대상을 확실하게 함으로써 프로그래밍 실수를 예방하기 위해서이다. (약간 타입스크립트? )

### 포인터 초기화하기
```c 
char c = "A";
char *pc = &c;

int n = 44;
int *n = &n;
```



### 주의점 

- 초기화하지 않고 사용하기 (포인터만 선언하게된다면 쓰레기 값을 가지게된다.)
```c
int main(void) {
	int *p;
	*p = 100; // 컴파일 에러가 발생한다.
}
```

### stack

- 지역변수와 매개변수는 그 값이 Stack에 할당된다.
Swap함수를 호출하는 순간 매개변수 x, y가 Stack에 할당되고 a와 b의 값이 각각 x, y에 복사된다.
따라서 Swap함수에서 값의 변화를 신나게 줘도 인자에 어떤 영향도 가지 않으며 우리는 이것을 Call by value라고 부른다.


### call by value
- 함수 호출 시 넘기는 인자의 값이 매개변수에 복사(Copy)돼서 함수 내에서 매개변수에 직접적인 데이터 조작을 가해도 인자에 전혀 영향을 주지 않는다.

### call by reference
- 함수 호출시,  복사되는 값이 데이터의 주소 값
- Call by reference란 말 그대로 참조값으로 함수를 호출했단 뜻 (참조값 = 포인터)
- C 언어는 기본적으로 call by vlaue의 형식이지만 **pointer**로 인해 call by reference 가 가능해진다.




### 포인터와 배열


#### 포인터와 배열의 관계
- 포인터와 배열은 서로 긴밀한 관계를 맺고 있으며, 어떤 부분에서는 서로 대체할수있음
- 배열의 이름 = 포인터 상수(주소값이 변경 안되는 포인터)
```c
int arr[3] = {10, 20, 30}; // 배열 선언

int* ptr_arr = arr;        // 포인터에 배열의 이름을 대입함

arr[0] = prt_arr[0]
```

- 크기
```c
배열의 이름을 이용한 배열의 크기 : 12

포인터를 이용한 배열의 크기 : 8
```


#### 배열의 포인터 연산

- 공식 
```c
arr이 배열의 이름이거나 포인터이고 n이 정수일 때,

arr[n] == *(arr + n);


// example
arr[0] = *(arr);
arr[1] = *(arr + 1);
arr[2] = *(arr + 2);
```

![[Pasted image 20221204175834.png]]


## 이중 포인터

- 포인터의 포인터
- 구구단, 2D, 이차원 자료 구현할때  이용

### 선언
```c
int i = 100;
int *p = &i;
int **q = &p;

*p = 200; // i = 200
**q = 300; // i = 300
```

