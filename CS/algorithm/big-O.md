## big-O 

### big-o함수
- 알고리즘의 효율성을 나타내는 지표 
- **O( ) 함수안에 하나의 수식을 넣어서 사용**
- ex) O(1), O(n), O(nm), O(n^2)
- big-O 함수의 계수는 비교에 영향을 줄수없음 but, 차수는 영향을 줄수있음

### big-O 순서
- **O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)** 등
	- 오른쪽으로 갈수록 규모가 더 큼



## 시간 복잡도

- 업계에서는 big-O 표기법을 쓴다.
	- big-O, big-Omega, big-theta가 존재한다.
	- 각각 상한, 하한, 딱 맞는 수행 시간을 의미함. 
	- 업계에서는 big-O를 쓰는것이 추세임 -> 상한값만을 쓴다.


### 시간 복잡도 - O(N), O(1)

```ad-example
문제 : 1부터 n 까지 합을 구하라.
```

(1)번의 방법
```c++
int main()
{
    int n, sum = 0;
    scanf("%d", &n);
    for(int i=1; i<=n; i++)
        sum += i;
        
    printf("%d",sum);
}
```
- 이에 대한 시간 복잡도를 big-O 표기법으로 나타내보면
	- for 문에서 총 3번의 연산이 필요하다.
		- `i <= n `
		- `i++ `
		- `sum += i`
	- 따라서, n 에 따라서 3N번의 연산이 필요함
	   -> O(3N) => **O(N)**

(2)번의 방법 -> 공식 이용
```c++
int main(){
    int N, sum;
    scanf("%d", &N);
    sum = N*(N+1)/2;
    printf("%d\n", sum);
}
```
- 이에 대한 시간 복잡도를 big-O 표기법으로 나타내보면
	- 총합을 구하는 식을 통해 N에 상관없이 연산 1번이 필요함
	  => **O(1)**



### 시간 복잡도 - O(NM), O(N^2)

```c++
int main(){
    int N, M;
    scanf("%d %d", &N, &M);
    for(int i=0; i<N; i++)
        for(int j=0; j<M; j++)
            printf("%d %d\n", i, j);
}
```
- 2중 for문일 경우,
	- 처음 for문은 N번 반복
	- 나중 for문은 M번 반복
	=> 시간 복잡도는 **O(NM)** 이 된다.
	
```c++
int main(){
    int N;
    scanf("%d", &N);
    for(int i=0; i<N; i++)
        for(int j=0; j<N; j++)
            printf("%d %d\n", i, j);
}
```
- 이 경우엔, N이 for문에 중복해서 쓰인것을 알수있다.
	- 처음 for문은 N번 반복
	- 나중 for문은 N번 반복
	=> 시간 복잡도는 O(N^2) 이 된다.


###  알고리즘과 시간복잡도

- 대략적인 연산에 드는 시간 판별이 가능해진다. 
	- 만약, O(NM)시간복잡도, N의 최대는 100, M의 최대는 1000이다. 
		=> 최대 100000번의 연산 과정이 든다고 짐장가능
		=> 제한시간 1초를 넘기지않음,		
	- but, O(NM) 시간복잡도, N의 최대는 10000, M의 최대는 10000
		=> 최대 1억번의 연산 과정이 든다.
		=> 제한 시간을 초과함
		
```ad-note
big-O의 시점에서 볼때, 차수를 줄여야 효율이 좋아졌다고 볼수있음

알고리즘 문제에서 시간초과가 뜰때 => 차수를 줄여야한다.
```



