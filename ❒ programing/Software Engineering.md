

# 설계 원리 
#### 전통적인 설계 원리와 주요 개념
- 단순성, 효율성, 분할, 계층화, 추상화, 모듈화
- 가장 대표적인 주요 특성
	- **효율성**
		- 처리 시간과 기억 공간
	- **단순성** 
		- 유지보수에 영향을 주는 가장 중요한 특성

#### 결합도와 응집도
 - **결합도 : 모듈 간에 서로 의존하는 정도**
	- 결합이 강하면 이해가 어렵고 변경 시 파급 효과가 크다.
	- 오류 전파 영향이 크고, 디버깅할때 복잡성이 높아진다.
	- 결합도를 알수있는 척도?
		- 모듈 간 인터페이스 수
		- 인터페이스의 복잡성
	- 결합의 종류
		- 내용 결합
			- 한 모듈이 다른 모듈의 내부 자료를 직접 참조
		- 공통 결합
			- 공통의 전역 변수 값을 쓰거나 변경
		- 제어 결합
			- 한 모듈이 다른 모듈의 제어 흐름 경로를 결정
			- 제어 요소가 전달될 때
			- 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.
		- 스탬프 결합
			- 모듈들이 데이터 구조를 공유
			- 인터페이스로 배열이나 레코드 등의 자료구조가 전달될 때
		- 데이터 자료 결합
			- 모듈간의 매개변수가 간단한 타입일 때
			- 모듈 간 인터페이스가 자료 요소로만 구성될 때
- **응집도 : 하나의 모듈안에서 수행되는 작업들이 서로 관련된 정도**
	- 모듈 안의 여러 요소들이 **하나의 목적을 위해** 유기적으로 연관되어있는것이 좋음
	- 높은 응집은
			- 재사용이 쉽고 이해하기 좋다.
			- 수정에 의해 받는 영향이 적다.
	- 응집의 종류
		- 정보적 응집
			- 각각 독립된 코드의 오퍼레이션이 같은 데이터에 대해 실행
		- 기능적 응집
			- 하나의 기능에 모두 기여
		- 교환적 응집
			- 동일한 데이터를 조작
		- 절차적 응집
			- 모듈안에 구성 요소들이 기능을 절차적이게 수행
		- 시간적 응집
			- 특정한 시간에 처리
		-  논리적 응집
			- 같은 범주의 기능을 수행
		- 우연적 응집
			- 단위 안 요소들이 아무 관계가 없음

#### 수준 별 나열(주관식)
- 결합
내용 -> 공통 -> 제어 -> 스탬프 -> 데이터

- 응프
정보적 -> 순차적 -> 기능적 -> 교환적 -> 절차적 -> 시간적 -> 논리적 -> 우연적

#### SOLID 법칙 5가지에 대한 개념(단답형 주관식 포함) 
SOLID 원칙 : 객체 지향 프로그래밍 및 설계의 다섯가지 기본 원칙

- Single Responsibility Principle : 단일 책임의 원리
- Open Close Principle : 개방 폐쇄의 원리
- Liskov Substition Principle : 리스코프 교체의 원리
- Interface Segregation Principle : 인터페이스 분리의 원리
- Dependency Inversion Principle : 의존관계 역전의 원리

개념
- **Single Responsibilitiy Principle : 단일 책임의 원리**
	- 한 [클래스](https://ko.wikipedia.org/wiki/%ED%81%B4%EB%9E%98%EC%8A%A4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99) "클래스 (컴퓨터 과학)")는 하나의 책임만 가져야 한다.
- **Open Close Principle : 개방 폐쇄의 원리**
	- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- **Liskov Substition Principle : 리스코프 교체의 원리**
	- 프로그램의 [객체](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4 "객체")는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- **Interface Segregation Principle : 인터페이스 분리의 원리**
	- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
	- 인터페이스 분리와 캡슐화
- **Dependency Inversion Principle : 의존관계 역전의 원리**
	- 추상화에 의존해야지, 구체화에 의존하면 안된다
	- 구체화된 모듈이 추상화된 모듈에게 의존이 역전되도록 설계

#### 클래스 다이어그램 설계를 근거로 Solid 위배 및 설계 내용 해석

---
# 아키텍처와 패턴
#### 아키텍처 스타일 별 개념 이해
- **클라이언트 서버형**
	- 서버 - 강력한 성능으로 자원을 관리하며 클라이언트가 요청하는 기능, 자원 제공
	- 클라이언트 - 자원의 사용을 위해 서버를 접속
	- 장점 : 데이터 집중화, 보안
	- 단점 : 병목, 고비용, 비강인성
		- 병목 :  **전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상**
	  ![](https://i.imgur.com/L986xBb.png)

- **계층형**
	- 소프트웨어 기능을 수직으로 상호작용하는 여러 층으로 분활
	- 각 층 사이에 메시지 교환
	- 장점 : 추상화 뷰 제공으로 이해가 쉬움, 캡슐화, 응집과 결합 양호, 재사용성 높음
	- 단점 : 이웃층과 커뮤니케이션 제한적, 결합력 낮아 시스템 게층 구성 어렵다, 계층간의 통신 비용 방생해 성능 저하 우려
	  
- **이벤트 기반 아키텍처**
	- 프로그램에서 감지되고 처리될수있는 사건 중심 유형
	- 이벤트 생산자와 소비자로 구성
		- 생산자 - 이벤트 스트림을 생성 
			- 이벤트 스트림 : **이벤트 데이터를 효율적으로 이동하는 프로세스**
		- 소비자 - 이벤트 수신
	- 이벤트는 실시간으로 전달되어 소비자가 응답할수있어야함
	- 대부분 상태 기반 처리
	- 장점 : 생산자 소비자 분리되어 캡슐화 및 응집, 높은 확장성, 이벤트 즉각 응답 가능
	- 단점 : 복잡성 높음, 정밀하고 정확한 이벤트 별 테스트, 오류 메시지와 제어 필요
	  ![](https://i.imgur.com/DwH9A8p.png)
	  
- **MVC (model-view-controller)**
	- 사용자 인터페이스로부터 비즈니스 로직과 데이터 분리
	  => 인터페이스의 응집도 개선, 다양한 ui 결합도 낮춤
	- 구성요소
		- 모델 - 데이터 상태 변화될때 컨트롤러와 뷰에 이를 통보
		- 뷰 - 사용자가 볼 결과물 생성
		- 컨트롤러 - 모델에 명령을 보냄
		
		![](https://i.imgur.com/ySwSZnk.png)

- **파이프 필터**
	- 필터 사이에 데이터를 이동시키며 단계적 처리
	- 데이터 흐름에 따라 입출력 및 데이터 변환을 수행하는 필터로 구성
	- 예 : 언어 컴파일러 
	- 장점 : 단순성, 필터 재사용 양호, 아키텍처 병렬성 제공
	- 단점 : 자원의 낭비, 오류 처리 문제
	  ![](https://i.imgur.com/qRhP7o5.png)
	  
- **데이터 중심 아키텍처**
	- 공유되는 자료가 중요한 시스템에서 채택
	- 공유 데이터 저장소, 공유데이터 접근자로 구성
	- 접근자
		- 공유데이터 추가, 삭제 및 수정
		- 특별한 통신 없이 공유 데이터를 통해 간접 수행
		- ![](https://i.imgur.com/2siGjts.png)
	- 대표 유형
		- 블랙보드 - 제어 스레드 포함, 옵서버 디자인 패턴 사용
		- 리파지토리 - 공유 데이터를 질의하여 변경 사항 발견
	- 장점 : 낮은 결합, 확장성
	- 단점 : 공유 데이터라는 단일 장애 지점 발생

- **peer-to-peer 스타일**
	- 각 컴포넌트는 동등하여 클라이언트인 동시에 서버 역할
	- 동일한 수신, 전송 데이터 양을 가지므로 대칭적인 시스템
	- 각 컴포너트 간 자원, 서비스, 컨텐츠 공유
	- 예 - 블록체인 기술 
	- 장점 : 전담 앱 서버가 없음, 규모 확장성 및 신뢰성 개선, 부분고장이라도 전체 가동 가능
	- 단점: 보안 취약 가능성, 중앙 제어 불가, 공유된 자원으로 성능 저하 위협
#### 패턴 별 개념과 사용 적절한 패턴 찾기
- **싱글톤 패턴**
	- 객체 강제적으로 하나만 생성
	- 시스템에서 단 하나의 인스턴스만 가짐
	- 방법
		- 클래스 자체를 정적 변수로 선언
		- 생성자 접근 수정함수를 private 선언
		- 유일한 객체를 접근하는 정적 메서드
		-  싱클톤 얻는 방법은 생성자에 위임
		  ![](https://i.imgur.com/NwG9DMg.png)

- **반복자 패턴**
	- 무엇인가 반복할때 iterator 객체 사용
		- itrator 객체 : 리스트나 트리, 그래프, 테이블 등
	- 집합에 소속된 요소들을 쉽게 접근하기위해 반복자에게 위임
	- 첫번째 요소, 다음 요소, 현재 포인터 가리키는 메소드 포함
	  ![](https://i.imgur.com/GxoTKnX.png)

- **어댑터 패턴**
	- 호환되지않는 인터페이스들을 연결하는 디자인 패턴
		  => 기존 클래스의 재사용
	- 어댑터 : 서비스가 제공하는 인터페이스를 클라이언트가 기대하는 인터페이스로 변환
	- 클래스 어댑터는 상속을 이용한 어댑터 패턴
	- 인스턴스 어댑터는 위임을 사용한 어댑터 패턴
	  ![](https://i.imgur.com/2JMf0jw.png)
	  - 동일한 동작이지만 다른 인터페이스로 오브젝트를 랩핑함 -> 호환성 초점

- **데코레이션 패턴**
	- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
	- 수정에 의한 추가
		- 대안은 상속에 의한 추가
		  ![](https://i.imgur.com/H87THI2.png)

	- 구성요소
		- component 클래스와 확장 기능이 담긴 데코레이터
	- 데코레이터 객체가 재귀 합성으로 compoenet 객체 매핑
	- 기본 클래스와 동일한 인터페이스 operation() 구현
		- 클라이언트가 operation() 호출할때 기본 객체와 데이레이터 객체 모두 필요한 모든 곳에서 사용 가능 (일종의 위임 기능)
		  ![](https://i.imgur.com/FJi7zrg.png)
		  - 랩핑 객체의 동작을 확장하면서 동일한 인터페이스 유지 -> 확장에 초점

- **추상 팩토리 패턴**
	- 클라이언트에서 구체적인 객체 생성을 지정하는 책임을 분리하기 위하여 추상 인터페이스만듬 
	  => 객체 패밀리를 생성
	  ![](https://i.imgur.com/st10rVg.png)


- **상태 패턴**
	- 객체의 상태에 따라 행위를 다르게 할 때, 상태를 객체화하여 필요에 따라 다르게 행동하도록 위임
	- 참조 방식에 따라 객체의 동작을 다르게 처리해야하는 경우
	- 이벤트 의존 애플리케이션에 적합한 패턴
	  ![](https://i.imgur.com/jLrBYbu.png)


- **옵서버 패턴**
	- 1대 다의 객체 의존관계 정의한것
	- subject 클래스
		- 옵서버 목록을 유지, 변경을 고지
	- observer 클래스
		- 외부 객체 상태변화에 따라 상속된 객체들에게 변화된 상태를 전달
		- 상속 객체들은 그에 맞게 기능을 수행
	- 예) 관심 블로그 알림
	  ![](https://i.imgur.com/EkH6q6g.png)


---

# UI 설계
#### UI 설계에 적용되고 있는 은유적 표현 기법들
설계와 구현에 사용되는 개념
- 마법사 : 미리 저장된 순서로 사용자를 안내
- 사이트 이동경로(breadcrumbs) : 웹사이트 앱에서 사용자의 위치를 표시하는 내비게이션
- 메타포 : 사용자의 개념적 인식 모델 (ex. pc 휴지통 아이콘)
- GUI 프레임워크 : 응용 프로그램을 위한 프레임워크 클래스 라이브러리를 사용하여 구현
- android, ios등 대상 플랫폼에서 제공하거나 언어라이브러리에서 제공

---

# 코딩 
#### 객체지향 코딩 로드맵
1. 코딩 표준 정의
2. 메소드 구현
3. 클래스 인스팩션
4. 단위 테스트
5. 통합을 위하여 릴리스

![](https://i.imgur.com/khFxjM1.png)


#### 프로그램 소스에서 발생 오류 찾기
1. 메모리 누수
	- 메모리 할당해놓고 프리하지 않을 때
2. 중복된 프리선언
	- 이미 프리한 자원을 또 프리할때
3. Null 선언
	- Null 포인트 하는곳에 접근할때
4. 별칭의 남용
	- 두개의 변수값이 별칭 선언으로 같은 값이 되었을때
5. 배열 인덱스 오류
	- 배열 인덱스가 범위를 벗어났을때
6. 수식 예외 오류
	- 0으로 나누는 오류
	- 변동 소수점 예외 오류
7. 하나 차이로 의한 오류
	- 0으로 시작할걸 1로 시작할때
	- <=n 으로 쓸걸 < n 으로 쓸때
8. 사용자 정의 자료형 오류
	- 오버플로우나 언더플로우 발생 가능성
9. 스트링 처리 오류
	- 스트링이 Null 로 끝나지 않을때
	- strcpy, sprint 등 스트링 처리 함수에서 buffer overrun 오류
10. 버퍼 오류
	- 버퍼에 복사값이 범위를 넘어서는 큰 값일때 오버플로 발생
11. 동기화 오류 
	- 공동 자원을 사용하는 스레드의 병렬 프로그램에서 자주 발생
	- 데드락(deadlock) - 다수의 스레드가 서로 자원을 점유하고 릴리스 하지않는 상태
	- 레이스 컨디션 - 두개의 스레드가 같은 자원에 접근하여 수행 결과가 다르게 되는 경우
	- 모순이 있는 동기화 - 공유하는 변수 접근할때, 로킹과 언로킹을 번갈아 하는 상황에서 발생
12. 교착 상태
13. 경쟁 상황

#### 코딩 표준
- 간결함 : 복잡하지 않고 명확
- 읽기 쉽다 : 이해하기 쉬운것
- 설계에서 **모듈화의 목표, 높은 응집력, 낮은 결합도**를 달성하면 모듈은 간단해짐
#### 코드 스멜과 그에 따른 리팩토리 방안
- 코드스멜
	- 프로그램에 대한 작업을 어렵게 만드는 것
	- 읽기 어려운 프로그램
	- 중복된 로직을 가짐
	- 실행중인 코드 변경 요구하는 로직 포함
	- 복잡한 조건문이 포함된 프로그램
![](https://i.imgur.com/9bW3hRR.png)
![](https://i.imgur.com/usgwJSV.png)

#### 코드 품질 향상을 위한 기법들 설명
- 인스팩션
	- 프로그램을 읽어보고 눈으로 확인하는 방법
- 정적 분석
	- 수행되지 않는 데드코드가 없는지, 선언되지않고 사용한 변수가 없는지 확인
- 테스트 중심 개발 (Test Driven Development)
	- 시스템의 핵심 부분에 대해 정확성을 테스트하는 방법
- 페어 프로그래밍
	- 프로그래밍과 테스팅을 담당하는 두 사람이 머신을 공유하며 코딩

---
# 테스트
#### SW품질 테스트 과정(단답형 주관식)
1. 테스트에 의하여 무엇을 점검할지 정한다.
2. 테스트 방법을 정한다.
3. 테스트 케이스를 개발한다
4. 테스트의 예상 결과를 작성한다.
5. 테스트 케이스로 실행한다.
   
#### 테스트 단계 별 이름과 주요 활동(단답형 주관식 일부 포함)
![](https://i.imgur.com/yMvEeCv.png)

#### 블랙박스 테스트 기법
- 내부 경로 지식을 보지 않고 테스트 대상의 성능이나 기능을 테스트

#### 화이트박스 테스트를 위한 테스트 케이스 찾기 & 기본 경로 수 계산 응용문제
- 구조적 테스트
	- 언시 코드로 애플리케이션의 구조 이해
	- 검증 기준 정하기
	- 경로를 구동시키는 테스트 케이스 준비
- 논리 흐름도를 이용

---

# 유지보수
#### 중요 용어(단답형 주관식)
- 결함을 고치거나 성능을 높이거나 새로운 기능을 추가하거나 변경된 환경에 적응시키기 위해 배포 후 수정하는 작업
#### 운영 활동과 유지보수 짝짓기
- 수정형 유지보수
- 적응형 유지보수
- 완전형 유지보수
- 예방형 유지보수
- 응급형 유지보수
#### 리먼의 소프트웨어 진화 법칙
- 시스템의 타입
	- E 타입 : 계속 진화하는 타입, 완벽한 개발 어려움
	- S 타입 : 완벽히 정의할 수 있는 타입
- E 타입의 소프트웨어 진화 법칙
	- 지속적인 변경의 원칙 : 계속 좋은 방향으로 진화되기 위해
	- 엔트로피, 복잡도 증가의 법칙 : 비용 및 구조 개선을 위한 재구조화
	- 자기 통제의 법칙 : 유지보수, 배포, 오류율 등 자기 통제 추세를 일반화하여 규칠화
	- 품질 저하의 법칙 : 운영환경에 완전한 적응이 아닌 한 품질 저하
	- 피드백 시스템의 법칙 : 여러 관련자들의 피드백에 의해 진화

#### 유지보수 프로세스 모델 중 하나
- **즉시 수정 모델**
	- 소수의 유지보수 담당자가 관리하고 결정할수있는 경우 적합함
	- 변경 효과를 간과할 가능성이 높음
- **반복적 개선 모델**
	- SW변경이 전체 생명주기 단계에 반복적 발생/개선되는 경우
	- 완벽한 문서화와 유지보수팀의 업무 분석 능력이 전제되어 가능
- **재사용 중심 모델**
	- 유지보수 작업을 프로그램 컴포넌트 재사용 개념으로 인식
	- 컴포넌트를 분류하고 변경을 가능케하는 프레임워크 필요
	- 재사용 컴포넌트를 위한 저장소 필요

#### 형상관리 4가지 절차(단답형 주관식)
형상관리 : 개발 주기동안 생성된 문서를 관리하고 소프트웨어 시스템과 컴포넌트의 상태를 추적하는 작업
- 변경사항을 체계적으로 추적, 통제
- 어떤 문서나 파일이 변경 되었을 경우 변경된 내역을 기록하였다가 나중에 이를 찾아보아야 할 경우, 변경 원인과 변경 사항을 확인해야 할 경우에 대한 관리
- **형상 관리 절차**
	- 소프트웨어 형상 파악
	- 형상 변경 제어
	- 소프트웨어 형상 검사
	- 소프트웨어 형상 상태 보관


#### 역공학 개념 이해
역공학 : **이미 만들어진 소프트웨어 시스템을 역으로 추적하여 처음의 문서나 설계기법 등의 자료를 얻어 내는 것을 의미**
- 낮은 추상 수준의 프로그램을 높은 추상 표현으로 복구하는 과정
- 역공학의 결과물은 최상의 추상 수준 or 재문서화
	- 재문서화 : 의미적으로 같은 추상 수준을 가진 표현을 생성하는 작업 











