---
tags:
  - data
  - big5
  - c++
  - array
---

### 실생활 활용 예시
- 카톡에서 친구 목록은 어떻게 유지? 
- 현재 친구가 아니지만 친구의 친구를 친구로 추천하고 싶음 이와 같은 관계가 많은 사용자를 우선적으로 추천하고 싶음 나와 공통 친구가 많은 사용자를 우선적으로 추천하고 싶음

### 개요
- 각 언어마다 구현 방법에 차이가 있음
	- 언어의 차이점 이해하기
- LIFO 방식으로 스택 구현하며 차이보기
	- 동적 자료구조 구현
		- 용량이 부족하면 배열 늘려줌(확대?)
	- C++ 기본 골격
```c++
class Stack{ private: size_t capacity; 
			size_t top{0}; // size
			int* items;
			 public: Stack(size_t capacity = 10):
			  capacity{capacity},
			  item{(capacity != 0)?
			        new int[capacity]: nullptr}{} };
```


## 기본 골격 비교
- C++은 template 기능을 이용하여 구현
	- C++는 나중에 타입 인자만큼의 클래스 구현을 만들어 처리함 적절하지 않은 타입 인자의 사용은 문법 검사를 통해 나타남
### 초깃값

- C++는 std::initializer_list를 이용하여 초깃값 목록을 받는 생성자를 정의할 수 있음
```c++
Stack(const std::initializer_list& initList):
	capacity{initList.size()}, top{capacity}, items{new int[capacity]}{
	std::copy(initList.begin(), initList.end(), items); 
}
```
- 초깃값 목록을 받는 생성자를 정의할 경우 중괄호를 이용한 자료구조를 생성할 때 주의
```c
std::vector vec1{5, 1}; // capacity = 2, size = 2, [5,1] 
std::vector vec2(5, 1); // capacity = 5, size = 5, [1,1,1,1,1]
```
### 소멸자, clear

- C++는 동적 할당한 것을 직접 반납해 주어야 함 
	- [[big5]]에 소멸자가 포함되어 있음 
	- [[Stack]]에서 clear는 공간 반납 없이 top을 0으로 설정하면 됨

### 동적 배열 기법
- 유지해야하는것
	- 동적 배열
	- 동적 배열 사용 정보 : 크기, 용량
		- [[c++ programming]]
			- 최대 용량 : 컴퓨터에 따라 다름 (size_t 최댓값)
				- size_t (부호가 없는 정수 타입, sizeof의 반환 타입)
			- 크기 정보  : top 
			- c++은 동적배열이 내부 멤버 변수로 불가피함 => **[[Big5]]** 필수
				- 소멸자, 복사 생성자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자
				- copy-and-swap idiom 활용하여 코드 중복 제거
			- **초깃값 목록**
				- std::initialize_list를 이용하여 초깃값 생성자 정의 가능
```c++
void increaseCapacity(){
	capacity *= 2;
	int* tmp{new int[capacity]};
	std::copy(items, items + top, tmp);
	delete [] items;
	items = tmp;
}
```
	- 용량을 두배로 늘리고, 늘린곳에 기존 데이터 복사
	- 그리고 반납, items에 다시 복사한것 할당?

- 2배로 늘려야하나???
	- 2배로 늘렸는데 쓰는 공간이 작으면 공간 낭비 됨 => 요즘은(?) 1.5배 or 1.2배로 늘림 (1배 이상)
	- 

### push, pop, peek


### 반복자
- 자료구조에 저장된 요소를 차례로 방문할수있는 반복자 제공
- c++ 반복자
	- 객체 : begin, end (2개)
	- 사용하는 연산 :  hasNext(==, !=) ; next(++) ; get( * )
	- 타입 : trait (5종류)
- 상수반복자, 일반반복자 정의 
	- 이와 같은 불편함을 줄이기 위해 template 이용
	- 일반 반복자와 상수 반복자를 위한 클래스를 별도 정의하지 않고 하나만 정의하기 위함
```c++
template <typename U>
class StackIterator{
public:
	using iterator_category = std::forward_iterator_tag;
	using value_type = U;
	using difference_type = std::ptrdiff_t;
	using pointer = U*;
	using reference = U&;
	...
```



### 실제 구현

- `top` 변수를 기준으로 구조를 짠다

#### 스택 구현

```c++

bool isEmpty() const noexcept{
	return top = 0;
}

size_t size() const noexcept{
	return top;
}
  
void clear() noexcept{
	top = 0;
}

int peek() const noexcept{
	if(isEmpty()) throw std::logic_error('');
	return items[top -1]
}

void push(int item){
	item[top] = item;
	++top;
}

int pop() noexcept{
	return item[--top];
}
```


### 기타
- c++ 연산자 다중 정의를 이용하여 자료구조 연산을 많이함 