## 동적 할당
### 프로그램 동작 원리
- 컴퓨터 구조
	- CPU, RAM(주기억장치), HDD(하드디스크/보조기억장치), OS(운영체제)
- 프로그램 실행 원리
	- 사용자는 OS를 통해 프로그램 실행 요청을 보낸다.
	- 하드디스크에 저장된 program 정보를 읽음 ->  RAM, 메모리의 프로그램 코드 영역에 올린다.
	- cpu는 program code를 읽음 -> 메모리를 관리하고 명령문을 실행함.
	-  프로그램 실행을 위한 동적 메모리 할당시 free store 영역을 사용
		- 아래로 확장한다.
	- system 작동을 위해 cpu가 임시 정보를 스택에 저장시 free store 영역을 사용
		- 위로 확장한다.
	- 만약, heap 과 stack 메모리를 많이 사용해 free store 영역이 없어지면 메모리 부족 상태가 됨.

![[Pasted image 20230211020924.png]]

### 메모리 영역별 특징
- program code 
	- 실행한 프로그램의 코드가 저장
- data
	- 전역변수
	- static 변수 
	- program 종료시까지 남아있는다
- heap
	- 동적 할당된 메모리 영역
	- C++ `new()` C언어 `malloc()`
	- C++ delete와 C언어 free 사용
	- 프로그래머가 할당, 해제
- stack 
	- 지역변수와 매개변수가 할당, 함수 종료시까지 자동 소멸된다.

### 동적 할당하는 이유
- 일시적으로 많은 메모리를 잡아야할때 사용함.
	- 프로그램을 실행하면 ram에 올라가서 돌게 되는데 ram의 메모리 자원은 한정적이다.
	-  프로세스 많이 필요한 상황일때,
		- 처음부터 끝까지 공간을 잡으면 메모리 낭비가 많이 일어난다.
		- 따라서 메모리를 필요한 상황에서만 잡고 다시 해지시키는 방법을 이용해야한다.
		- -> 결과적으로 메모리 공간을 효율적으로 이용할수있게된다.
		- == 이와 같은 것이 **동적할당**이다. 
- 함수 return 이후에도 메모리 할당이 살아있게 하고 싶은 경우
	- 지역 변수는 함수 종료시 같이 사라지기때문에
- 그때 그때 메모리를 요청하기 위해
	- 대표적인 예시로, `vector` 가 있다.

## 동적 할당 특징
- 꼭 쌍을 맞추어 사용 
	- 일부만 해제되는 문제 발생 가능
	-  malloc - free
	- new - delete
	- new[] - delete[]
- 메모리 해제후 포인터의 경우 `NULL` 로 초기화해 에러를 방지한다.


## 동적 배열 기법
- 유지해야하는것
	- 동적 배열
	- 동적 배열 사용 정보 : 크기, 용량
		- [[c++ programming]]
			- 최대 용량 : 컴퓨터에 따라 다름 (size_t 최댓값)
				- size_t (부호가 없는 정수 타입, sizeof의 반환 타입)
			- 크기 정보  : top 
			- c++은 동적배열이 내부 멤버 변수로 불가피함 => **[[Big5]]** 필수
				- 소멸자, 복사 생성자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자
				- copy-and-swap idiom 활용하여 코드 중복 제거
			- **초깃값 목록**
				- std::initialize_list를 이용하여 초깃값 생성자 정의 가능
```c++
void increaseCapacity(){
	capacity *= 2;
	int* tmp{new int[capacity]};
	std::copy(items, items + top, tmp);
	delete [] items;
	items = tmp;
}
```
	- 용량을 두배로 늘리고, 늘린곳에 기존 데이터 복사
	- 그리고 반납, items에 다시 복사한것 할당?

- 2배로 늘려야하나???
	- 2배로 늘렸는데 쓰는 공간이 작으면 공간 낭비 됨 => 요즘은(?) 1.5배 or 1.2배로 늘림 (1배 이상)

#### 사용법
- 자료구조 생성할때 데이터 개수 미리 알면 적절한 용량으로 확보
	- 내부적으로 여러번 확장보다 처음에 충분히 확보하는게 효과적임
	- 여러번 자동 확장하는것보다 특정 시점에서 충분히 확장할수있다면 하는게 좋음
- 다음을 파악하여 효과적으로 할수있어야한다.
	- 총 삽입하는 데이터 수
	- 데이터를 삽입하는 특성 (빈도, 주기, 간격, 양 등)
#### push
```cpp
void push(int item){
	if(top==capacity) increaseCapacity();
	items[top++] = item;
}
```
#### pop
```cpp
int pop(){
	if(top == 0){
		throw std::runtime_error("");
		return items[--top]; //c++ 표준 라이브러리는 보통 pop이 값을 반환하지않음
	}
}
```
#### peek
```cpp
int peek(){
	if(top == 0)
		throw std::runtime_error("");
	return items[top-1];
}
```

